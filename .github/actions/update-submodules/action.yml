name: 'Update Submodules'
description: 'Update git submodules to their latest commits or tags'

inputs:
  strategy:
    description: 'Strategy to use (commit or tag)'
    required: false
    default: 'commit'
  token:
    description: 'GitHub token for authentication'
    required: true

runs:
  using: 'composite'
  steps:
    - name: Update submodules
      shell: bash
      env:
        GIT_TOKEN: ${{ inputs.token }}
        STRATEGY: ${{ inputs.strategy }}
      run: |
        # Exit on error, undefined variables, and pipe failures
        set -euo pipefail
        
        # Lock file to prevent race conditions
        LOCK_FILE="/tmp/git-submodule-update-$$.lock"
        
        # Function to acquire lock
        acquire_lock() {
          local lock_file="$1"
          local max_attempts=30
          local attempt=1
          
          while [[ $attempt -le $max_attempts ]]; do
            if (set -C; echo $$ > "$lock_file") 2>/dev/null; then
              echo "Lock acquired: $lock_file"
              return 0
            fi
            
            echo "Waiting for lock... (attempt $attempt/$max_attempts)"
            sleep 2
            ((attempt++))
          done
          
          echo "Error: Could not acquire lock after $max_attempts attempts"
          return 1
        }
        
        # Function to release lock
        release_lock() {
          local lock_file="$1"
          if [[ -f "$lock_file" ]]; then
            rm -f "$lock_file" 2>/dev/null || true
            echo "Lock released: $lock_file"
          fi
        }
        
        # Cleanup function to restore original state
        cleanup() {
          echo "Cleaning up..."
          rm -f "$GIT_ASKPASS" 2>/dev/null || true
          release_lock "$LOCK_FILE"
          # Restore original Git config - clean up only what we set
          git config --global --unset-all url."https://x-access-token:$GIT_TOKEN@github.com/".insteadOf "https://github.com/" 2>/dev/null || true
          git config --global --unset-all url."https://x-access-token:$GIT_TOKEN@github.com/".insteadOf "git@github.com:" 2>/dev/null || true
          git config --global --unset-all url."https://x-access-token:$GIT_TOKEN@github.com/".insteadOf "ssh://git@github.com" 2>/dev/null || true
        }
        
        # Set trap to ensure cleanup runs on exit
        trap cleanup EXIT
        
        # Acquire lock to prevent race conditions
        acquire_lock "$LOCK_FILE" || {
          echo "Error: Failed to acquire lock. Another instance may be running."
          exit 1
        }
        
        # Proactive cleanup to handle SIGKILL scenarios
        cleanup_previous_run() {
          echo "Checking for previous run artifacts..."
          # Clean up any existing global configurations that might have been left behind
          git config --global --unset-all url."https://x-access-token:".insteadOf 2>/dev/null || true
          # Clean up any temporary files from previous runs
          rm -f /tmp/.git-askpass-* 2>/dev/null || true
          rm -f /tmp/git-submodule-update-*.lock 2>/dev/null || true
          echo "Previous run cleanup completed"
        }
        
        # Check for existing configurations before proceeding
        check_existing_config() {
          if git config --global --get-all url."https://x-access-token:".insteadOf >/dev/null 2>&1; then
            echo "Warning: Found existing git config from previous run. Cleaning up..."
            cleanup_previous_run
          fi
        }
        
        # Note: SIGKILL cannot be trapped. If the process is killed with SIGKILL,
        # cleanup won't run. This proactive cleanup handles such scenarios.
        cleanup_previous_run
        check_existing_config
        
        # Validate strategy input
        if [[ "$STRATEGY" != "commit" && "$STRATEGY" != "tag" ]]; then
          echo "Error: Invalid strategy '$STRATEGY'. Must be 'commit' or 'tag'"
          exit 1
        fi
        
        # Check if submodules exist
        if [[ ! -f .gitmodules ]]; then
          echo "No submodules found in this repository"
          exit 0
        fi
        
        echo "Updating submodules using strategy: $STRATEGY"
        
        # Configure Git authentication for this step with secure permissions
        export GIT_ASKPASS=/tmp/.git-askpass-$$
        (umask 077 && echo 'echo $GIT_TOKEN' > "$GIT_ASKPASS")
        chmod 700 "$GIT_ASKPASS"
        
        # Configure Git to use HTTPS with the token (global config with proper cleanup)
        echo "Configuring Git authentication..."
        git config --global url."https://x-access-token:$GIT_TOKEN@github.com/".insteadOf "https://github.com/" || {
          echo "Warning: Failed to configure HTTPS URL replacement"
        }
        git config --global url."https://x-access-token:$GIT_TOKEN@github.com/".insteadOf "git@github.com:" || {
          echo "Warning: Failed to configure SSH URL replacement"
        }
        git config --global url."https://x-access-token:$GIT_TOKEN@github.com/".insteadOf "ssh://git@github.com" || {
          echo "Warning: Failed to configure SSH protocol URL replacement"
        }
        
        # Initialize submodules if not already done
        if ! git submodule status --recursive >/dev/null 2>&1; then
          echo "Initializing submodules..."
          git submodule update --init --recursive || {
            echo "Error: Failed to initialize submodules"
            exit 1
          }
        fi
        
        if [[ "$STRATEGY" == "tag" ]]; then
          echo "Configuring submodules to use latest tags..."
          
          # Track if any submodule failed to update
          submodule_failures=0
          
          # Update submodules to latest tags with proper error handling
          git submodule foreach --recursive '
            echo "Processing submodule: $displaypath"
            git fetch --tags || {
              echo "Warning: Failed to fetch tags for $displaypath"
              exit 1
            }
            
            latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [[ -n "$latest_tag" ]]; then
              echo "  Checking out latest tag: $latest_tag"
              git checkout "$latest_tag" || {
                echo "Error: Failed to checkout tag $latest_tag for $displaypath"
                exit 1
              }
            else
              echo "  Warning: No tags found for $displaypath, staying on current branch"
              exit 0
            fi
          ' || {
            submodule_failures=1
          }
          
          if [[ $submodule_failures -eq 1 ]]; then
            echo "Error: Some submodules failed to update to latest tags"
            exit 1
          fi
          
          # Show which tag each submodule moved to
          echo "Submodules updated to latest tags:"
          git submodule foreach --recursive '
            latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "no tags found")
            echo "  - $displaypath: $latest_tag"
          '
        else
          echo "Using default branch tracking..."
          
          # Update submodules with default behavior
          git submodule update --init --recursive --remote || {
            echo "Error: Failed to update submodules"
            exit 1
          }
          
          # Show which commit each submodule moved to
          echo "Submodules updated to latest commits:"
          git submodule foreach --recursive '
            commit_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
            commit_msg=$(git log -1 --pretty=format:"%s" 2>/dev/null || echo "no message")
            echo "  - $displaypath: $commit_hash ($commit_msg)"
          '
        fi
        
        echo "Submodules updated successfully"
